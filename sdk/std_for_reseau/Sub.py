# encoding=utf-8"""根据标准差来计算格子"""import numpy as npimport pandas as pdimport copyfrom server.futures.futures_sub.future_global_value import debug_datefrom data_source.Data_Sub import get_k_data_jqfrom data_source.auth_info import jq_loginfrom sdk.MyTimeOPT import add_date_str, get_current_date_strfrom data_source.stk_data_class import StkDatafrom my_config.log import MyLogimport logginglogger_debug = MyLog('reseau_cal').loggerlogger_eml = MyLog('reseau_cal_eml', file_level=logging.DEBUG).logger"""---------------------- 定义全局变量 ------------------------"""today_df_update_date = ''today_df = pd.DataFrame()class Reseau(StkData):    """    动态网格策略底层实现类    """    def __init__(self, stk_code):        # 将一天用的网格信息记录下来，        # 避免每次重复计算，实现一天只计算一次        super().__init__(stk_code)        self.stk_code = stk_code    def cal_rt_rsv(self):                try:            t_d = copy.deepcopy(self.today_df)                        # 向df中增加rsv信息            t_d['c_last'] = t_d['close'].shift(1)            t_d = t_d.dropna(axis=0)            logger_debug.debug('未经过“根据c_last修正hl”之前的数据：\n%s' %t_d.to_string())                        # 根据上次c对当天的hl进行修正            t_d.loc[:, 'high'] = t_d.apply(lambda x: np.max([x['high'], x['c_last']]), axis=1)            t_d.loc[:, 'low'] = t_d.apply(lambda x: np.min([x['low'], x['c_last']]), axis=1)            logger_debug.debug('经过“根据c_last修正hl”后的数据：\n%s' % t_d.to_string())                        # 计算每天权重            t_d.loc[:, 'w'] = t_d.apply(lambda x: x['high']-x['low'], axis=1)                        # 计算每天rsv            t_d.loc[:, 'rsv'] = t_d.apply(lambda x: np.min([1, np.max([0, (x['close']-x['low'])/(x['high']-x['low']+1e-30)])]), axis=1)            logger_debug.debug('计算权重和rsv后的数据：\n%s' % t_d.to_string())                        # 用最近三天rsv加权得到最终rsv            t_d_tail = t_d.tail(3)            w_total = np.sum(t_d_tail['w'].values)            t_d_tail.loc[:, 'w_std'] = t_d_tail.apply(lambda x: x['w']/(w_total+1e-100), axis=1)            t_d_tail.loc[:, 'rsv_w'] = t_d_tail.apply(lambda x: x['w_std']*x['rsv'], axis=1)            rsv = np.sum(t_d_tail['rsv_w'])                        logger_debug.debug('最终rsv数据：\n%s \n最终rsv值：%0.2f' % (t_d_tail.to_string(), rsv))                        return rsv        except Exception as e_:            logger_eml.exception('计算实时rsv出错，原因：\n %s' % str(e_))            return 0.5                @staticmethod    def get_single_stk_reseau_sub(df_, slow=6, quick=3):        """        计算动态网格        :param quick:        :param slow:        :param df_:        :return:        """        return np.mean([np.std(df_.tail(quick).loc[:, ['low', 'high']].values),                        np.std(df_.tail(slow).loc[:, ['low', 'high']].values)])    def get_single_stk_reseau(self, stk_code):        """        计算单只stk的当前网格        :return:        """        # df = my_pro_bar(stk_code=stk_code, start=add_date_str(get_current_date_str(), -10))        df_ = get_k_data_jq(stk=stk_code, start_date=add_date_str(get_current_date_str(), -10),                            end_date=get_current_date_str())        if len(df_) < 7:            # df = my_pro_bar(stk_code=stk_code, start=add_date_str(get_current_date_str(), -30))            df_ = get_k_data_jq(stk=stk_code, start_date=add_date_str(get_current_date_str(), -30),                                end_date=get_current_date_str())        return self.get_single_stk_reseau_sub(df_)    def get_rt_reseau(self, p_now, slow=4, quick=2):        """        实时计算reseau值        :param quick:        :param slow:        :param p_now:        :return:        """        # 更新df        self.update_today_hlc(p_now)        # 计算reseau        std_q = np.std(self.today_df.tail(quick).loc[:, ['low', 'high']].values)        std_s = np.std(self.today_df.tail(slow).loc[:, ['low', 'high']].values)        std_w = std_q*0.67 + std_s*0.33        logger_debug.debug('实时格子计算today_df：\n%s\n' % self.today_df.to_string())        logger_debug.debug('实时格子计算结果：\n快线：%d 慢线：%d\n快线std：%0.2f 慢线std：%0.2f\n最终：%0.2f\n' %(quick, slow, std_q, std_s, std_w))        return std_w"""df.plot('date', ['close', 'std_m'], subplots=True)"""if __name__ == '__main__':    jq_login()    rs = Reseau('000001')    end = 0